<?php
// +-----------------------------------------------------------------+
// | MIOLO - Miolo Development Team - UNIVATES Centro Universitário  |
// +-----------------------------------------------------------------+
// | Copyleft (l) 2001 UNIVATES, Lajeado/RS - Brasil                 |
// +-----------------------------------------------------------------+
// | Licensed under GPL: see COPYING.TXT or FSF at www.fsf.org for   |
// |                     further details                             |
// |                                                                 |
// | Site: http://miolo.codigoaberto.org.br                          |
// | E-mail: vgartner@univates.br                                    |
// |         ts@interact2000.com.br                                  |
// +-----------------------------------------------------------------+
// | Abstract: This file contains utils functions                    |
// |                                                                 |
// | Created: 2001/08/14 Thomas Spriestersbach                       |
// |                     Vilson Cristiano Gärtner,                   |
// |                                                                 |
// | History: Initial Revision                                       |
// +-----------------------------------------------------------------+

/**
 * Brief Class Description.
 * Complete Class Description.
 */
class MUtil
{
/**
 * Brief Description.
 * Complete Description.
 *
 * @param $value1 (tipo) desc
 * @param $value2 (tipo) desc
 *
 * @returns (tipo) desc
 *
 */
    function NVL($value1, $value2)
    {
        return ($value1 != NULL) ? $value1 : $value2;
    }

/**
 * Brief Description.
 * Complete Description.
 *
 * @param $value1 (tipo) desc
 * @param $value2 (tipo) desc
 * @param $value3 (tipo) desc
 *
 * @returns (tipo) desc
 *
 */
    function IfNull($value1, $value2, $value3)
    {
        return ($value1 == NULL) ? $value2 : $value3;
    }

/**
 * Brief Description.
 * Complete Description.
 *
 * @param &$value1 (tipo) desc
 * @param $value2 (tipo) desc
 *
 * @returns (tipo) desc
 *
 */
    function SetIfNull(&$value1, $value2)
    {
        if ($value1 == NULL) $value1 = $value2;
    }

/**
 * Brief Description.
 * Complete Description.
 *
 * @param &$value1 (tipo) desc
 * @param $value2 (tipo) desc
 *
 * @returns (tipo) desc
 *
 */
    function SetIfNotNull(&$value1, $value2)
    {
        if ($value2 != NULL) $value1 = $value2;
    }

/**
 * @todo TRANSLATION
 * Retorna o valor booleano da variável
 * Função utilizada para testar se uma variável tem um valor booleano, conforme definição: será verdadeiro de 
 *      for 1, t ou true... caso contrário será falso.
 *
 * @param $value (misc) valor a ser testado
 *
 * @returns (bool) value
 *
 */
    function getBooleanValue($value)
    {
        $trues = array('t','1','true');

        if( is_bool($value) )
        {
            return $value;
        }

        return in_array($value,$trues);
    }

    function getMemUsage()
    {
     
       if (function_exists('memory_get_usage'))
       {
           return memory_get_usage();
       }
       else if ( substr(PHP_OS,0,3) == 'WIN')
       {
           // Windows 2000 workaround

           $output = array(); 
           exec('pslist ' . getmypid() , $output); 
           return trim(substr($output[8],38,10));
       }
       else
       {
           return '<b style="color: red;">no value</b>';
       }
    }

    function unix2dos($arquivo) 
    {
        $file = file("$arquivo");
        foreach($file as $texto)
        {
            $conteudo.= substr($texto,0,-1) . "\r\n";
        }
        if(is_writable($arquivo)) 
        {
            $manipular = fopen("$arquivo", "w");
            fwrite($manipular, $conteudo);
            fclose($manipular);
        }
        else
        {
            throw new EControlException("O arquivo: \"$arquivo\"  n&atilde;o possui permiss&otilde;es de leitura/escrita.");
        }
    }
}
/**
 * Brief Class Description.
 * Complete Class Description.
 */
class MVarDump
{
/**
 * Attribute Description.
 */
    var $var;

    
/**
 * Brief Description.
 * Complete Description.
 *
 * @param &$var (tipo) desc
 *
 * @returns (tipo) desc
 *
 */
    function VarDump(&$var)
    {
        $this->var =& $var;
    }
    
/**
 * Brief Description.
 * Complete Description.
 *
 * @returns (tipo) desc
 *
 */
    function Generate()
    {
        echo "<b>Variable Dump:</b><br><br>\n";
        echo "<blockquote>\n";
        echo "<pre>\n";
        var_dump($this->var);
        echo "</pre>\n";
        echo "</blockquote>\n";
    }
}

/**
 * Brief Class Description.
 * Complete Class Description.
 */
class MInvertDate
{
/**
 * Attribute Description.
 */
    var $separator='/';

/**
 * Attribute Description.
 */
	var $date;


/**
 * Brief Description.
 * Complete Description.
 *
 * @param $date (tipo) desc
 *
 * @returns (tipo) desc
 *
 */
	function __construct($date=null)
	{
		$date = strstr($date,'-') ? str_replace('-', $this->separator, $date) : str_replace('.', $this->separator, $date);
		$this->date = $date;
		$this->FormatDate();
	}

	Function FormatDate()
	{
		list($obj1, $obj2, $obj3) = split($this->separator, $this->date, 3);
		$this->date = $obj3 . $this->separator . $obj2 . $this->separator . $obj1;
		if ( ( $this->date == ($this->separator . $this->separator) ) )
			$this->date = 'Invalid Date!';
		return $this->date;
	}
}

// formata o valor conforme n casas decimais
/**
 * Brief Class Description.
 * Complete Class Description.
 */
class MFormatValue
{
/**
 * Attribute Description.
 */
	var $value;


/**
 * Brief Description.
 * Complete Description.
 *
 * @param $value (tipo) desc
 * @param $precision2 (tipo) desc
 *
 * @returns (tipo) desc
 *
 */
	function __construct($value,$precision=2)
	{
		//$this->value = sprintf("%." . $precision . "f",$value);
		$this->value = number_format($value,$precision,',','.');
		return $this->value;
	}
}

/**
 * Brief Class Description.
 * Complete Class Description.
 */
class MQuotedPrintable
{
/**
 * Brief Description.
 * Complete Description.
 *
 * @param $str (tipo) desc
 *
 * @returns (tipo) desc
 *
 */
  function encode($str)
  {
    define('CRLF', "\r\n");
    $lines = preg_split("/\r?\n/", $str);
    $out     = '';
    
    foreach ($lines as $line)
    {

        $newpara = '';
        
        for ($j = 0; $j <= strlen($line) - 1; $j++)
        {
            $char = substr ( $line, $j, 1 );
            $ascii = ord ( $char ); 
            
            if ( $ascii < 32 || $ascii == 61 || $ascii > 126 ) 
            {
                 $char = '=' . strtoupper ( dechex( $ascii ) );
            }
            
            if ( ( strlen ( $newpara ) + strlen ( $char ) ) >= 76 ) 
            {
                $out .= $newpara . '=' . CRLF;   $newpara = '';
            }
            $newpara .= $char;
        }
        $out .= $newpara . $char;
    }
    return trim ( $out );   
  }

/**
 * Brief Description.
 * Complete Description.
 *
 * @param $str (tipo) desc
 *
 * @returns (tipo) desc
 *
 */
  function decode( $str ) 
  {
    $out = preg_replace('/=\r?\n/', '', $str);
    $out = preg_replace('/=([A-F0-9]{2})/e', chr( hexdec ('\\1' ) ), $out);
    
    return trim($out);
  }

}

/**
 * Brief Class Description.
 * Complete Class Description.
 */
class MTreeArray
{
/**
 * Attribute Description.
 */
    var $tree;


/**
 * Brief Description.
 * Complete Description.
 *
 * @param $ (tipo) desc
 * @param $group (tipo) desc
 * @param $node (tipo) desc
 *
 * @returns (tipo) desc
 *
 */
    function __construct($array, $group, $node)
    { 
        $this->tree = array();
        if ($rs = $array)
        {
            $node = explode(',',$node);
            $group = explode(',',$group);
            foreach($rs as $row)
            {
                $aNode = array();
                foreach($node as $n) $aNode[] = $row[$n];
                $s = '';
                foreach($group as $g) $s .= '[$row[' . $g . ']]';
                eval("\$this->tree$s"."[] = \$aNode;");
            }
        }
    }
}

class MDummy
{
}
?>
